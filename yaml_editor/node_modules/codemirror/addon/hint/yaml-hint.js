(function(mod) {
    if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
    else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
    else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
    "use strict";

    var hintHelper = require('./yaml-hint-helper.js');

    function getHints(cm, options) {

        // this will contain the "path" to the current section of the YAML
        // file that the cursor is in
        var sectionPath = [];
        var cur = cm.getCursor();
        hintHelper.getSectionPath(cm, cur, sectionPath);

        var schemaObject = options.schemaInfo;
        var relevantSchemaObject = hintHelper.traverseSchemaObject(schemaObject, sectionPath);

        if(sectionPath.length > 1){

            // then the cursor is not at the section adjacent to the top

            var parentSectionInfo = sectionPath[sectionPath.length - 1];

            // check if the value of the parent field is a collection
            // data structure (like an object), or a simpler data structure
            // (like a string), because this will influence how
            // relevantSchemaObject should be accessed

            if(relevantSchemaObject.valueType === "ObjectArrayMeta"){
                // we know to look for the different field names in the "type"
                // attribute of relevantSchemaObject
                var schemaFieldNames = Object.keys(relevantSchemaObject["type"]);
            }
            else if(relevantSchemaObject.valueType === "ObjectMeta"){
                // we know to look for the different field names in the
                // "attributes" attribute of relevantSchemaObject
                var schemaFieldNames = Object.keys(relevantSchemaObject["attributes"]);
            }
            else{
                console.log("Unknown relevantSchemaObject.valueType encountered:\n%s",
                        relevantSchemaObject.valueType);
            }

            var usedFieldNames = hintHelper.getAlreadyUsedFields(cm, cur,
                    parentSectionInfo["sectionInfo"].lineno, false); 
        }
        else if(sectionPath.length === 1){
            var parentSectionInfo = sectionPath[0];
            var usedFieldNames = hintHelper.getAlreadyUsedFields(cm, cur,
                    parentSectionInfo["sectionInfo"].lineno, true);
            var schemaFieldNames = Object.keys(relevantSchemaObject["attributes"]);
        }

        var usedFieldNamesSet = new Set(usedFieldNames);
        var schemaFieldNamesSet = new Set(schemaFieldNames);
        var unusedSchemaFieldsSet = new Set([...schemaFieldNamesSet].filter(x => !usedFieldNamesSet.has(x)));
        var unusedSchemaFieldsArray = Array.from(unusedSchemaFieldsSet);

        var currentIndentLevel = hintHelper.getCurrentLineIndent(cm, cur);

        if(currentIndentLevel > 0){
            var isAtSectionEnd = hintHelper.checkIfAtInnerSectionEnd(cm, cur,
                    sectionPath[sectionPath.length - 1]);

        }
        else if(currentIndentLevel === 0){
        
            var isAtSectionEnd = hintHelper.checkBottomPartIfAtOuterLevel(cm, cur);
        
        }

        if(isAtSectionEnd){
            var hintMenuObjectList = hintHelper.generateHintText(unusedSchemaFieldsArray,
                    relevantSchemaObject);
        }
        else{
            var hintMenuObjectList = [];
        }

        return {
            list: hintMenuObjectList,
            from: {line: cur.line, ch: cur.ch},
            to: {line: cur.line, ch: cur.ch + 1}
        }

    }

    CodeMirror.registerHelper("hint", "yaml", getHints);

});
