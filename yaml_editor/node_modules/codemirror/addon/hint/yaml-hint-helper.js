var leadingWhitespaceRegex = /^\s*$/;
var typeidRegex = /^[a-z0-9]+:[a-z0-9]+\/([a-zA-Z0-9]+):[0-9]+\.[0-9]+$/;
var metaTypeidRegex = /Meta:/;

function getFirstUsefulToken(tokenList){

    if(tokenList.length === 0){
        var firstUsefulToken = null;
    }

    for(var j = 0; j < tokenList.length; j++){
        if(tokenList[j].type !== "meta" &&
                tokenList[j].type !== null){
            var firstUsefulToken = tokenList[j];
            break;
        }
        else{
            var firstUsefulToken = null;
        }
    }

    return firstUsefulToken;
    
}

function getFirstNonEmptyLineno(cm, lineno){

    var firstNonEmptyLineno = cm.lastLine();

    for(var i = lineno + 1; i < cm.lastLine() + 1; i++){
        var lineContent = cm.getLine(i);

        if(!leadingWhitespaceRegex.test(lineContent) && lineContent.length > 0){
            firstNonEmptyLineno = i;
            break;
        }
    }

    return firstNonEmptyLineno;

}

function getLastNonEmptyLine(cm, lineno){

    if(lineno === 0){
        return -1;
    }

    for(var i = lineno - 1; i > -1; i--){
        var lineContent = cm.getLine(i);

        if(!leadingWhitespaceRegex.test(lineContent) && lineContent.length > 0){
            return i;
        }
    }
}

function getInnerParent(cm, currentLineno, currentIndentLevel){

    // get token of parent section for the levels under the topmost level

    for(var i = currentLineno - 1; i > 0; i--){

        var previousLineTokens = cm.getLineTokens(i);
        var firstUsefulToken = getFirstUsefulToken(previousLineTokens);

        if(firstUsefulToken && firstUsefulToken.state.keyCol < currentIndentLevel){
            var parentLevelLineInfo = {
                parentLevelToken: firstUsefulToken,
                lineno: i
            }
            break;
        }
    }

    return parentLevelLineInfo;
}

function getFieldValue(cm, lineno){

    var lineTokens = cm.getLineTokens(lineno);
    var fieldValue = "";
    var valueFlag = false;

    for(var i = 0; i < lineTokens.length; i++){

        if(valueFlag){
            fieldValue += lineTokens[i].string;
        }
        if(lineTokens[i].state.pairStart){
            valueFlag = true;
        }

    }

    return fieldValue;

}

function getTopLevelParentInfo(cm){

    // for now, it's assumed that the thing whose attributes/fields are
    // being edited in the YAML file will be given at the top of the file
    // somewhere as "typeid: name-of-thing"
    var typeStringRegex = /typeid\:/;
    var topLevelParentLineno = null;

    for(var i = 0; i < cm.lastLine() + 1; i++){

        var lineContent = cm.getLine(i);

        if(typeStringRegex.test(lineContent)){
            topLevelParentLineno = i;
            break;
        }

    }

    var parentValue = getFieldValue(cm, topLevelParentLineno);
    var topLevelParentToken = getFirstUsefulToken(cm.getLineTokens(topLevelParentLineno));

    if(topLevelParentLineno !== null){
        return {
            sectionValue: parentValue,
            sectionInfo: {
                lineno: topLevelParentLineno,
                parentLevelToken: topLevelParentToken
            }
        }
    }
    else{
        console.log("Unable to find the name of the top level parent section");
    }

}

export function checkIfAtInnerSectionEnd(cm, cur, parentLevelLineInfo){

    var currentLineContent = cm.getLine(cur.line);
    var isCurrentLineEmpty = leadingWhitespaceRegex.test(currentLineContent);

    // get the first non-empty line below the current line to then compare
    // its indentation level to the parent section of the current line

    var firstNonEmptyLineno = getFirstNonEmptyLineno(cm, cur.line)
    var isNextLineIndentedToParentLevel = false;

    if(cur.ch === 0){
        var isCursorAtRightIndentLevel = cur.ch ===
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol;
    }
    else{
        var isCursorAtRightIndentLevel = cur.ch ===
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol + 2;
    }

    // check if the first non-empty line that is encountered below the
    // current one is indented to the same level that the current section's
    // parent is, or to any level above the parent's section indent level

    if(firstNonEmptyLineno !== cm.lastLine()){

        var lineTokens = cm.getLineTokens(firstNonEmptyLineno);
        var firstUsefulToken = getFirstUsefulToken(lineTokens);

        isNextLineIndentedToParentLevel = firstUsefulToken.state.keyCol <=
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol;
    
    }
    else{
        isNextLineIndentedToParentLevel = true;
    }

    return isCurrentLineEmpty && isNextLineIndentedToParentLevel &&
        isCursorAtRightIndentLevel;

}

export function checkIfAtTopLevelEnd(cm, cur){

    for(var i = cur.line; i < cm.lastLine() + 1; i ++){
        var lineContent = cm.getLine(i);
        if(!leadingWhitespaceRegex.test(lineContent)){
            return false;
        }
    }

    return true;

}

export function getCurrentLineIndent(cm, cur){

    var token = cm.getTokenAt(cur);
    var goodCurrentToken = getFirstUsefulToken(cm.getLineTokens(cur.line));

    if(!goodCurrentToken){
        goodCurrentToken = token;
    }

    if(goodCurrentToken.start === 0 && goodCurrentToken.end === 0 &&
            goodCurrentToken.state.keyCol === 0){
        // for the case when we really have an empty line
        var currentIndentLevel = 0;
    }
    else if(goodCurrentToken.start === 0 && goodCurrentToken.end === 0 &&
            goodCurrentToken.string.length === 0){
        // for when an empty line with zero indentation gets a non-zero keyCol
        var currentIndentLevel = 0;
    }
    else if((goodCurrentToken.end - goodCurrentToken.start === 1) &&
            goodCurrentToken.state.keyCol === 0){
        // for when a line has non-zero indentation but has a zero keyCol value
        var currentIndentLevel = goodCurrentToken.end;
    }
    else{
        var currentIndentLevel = goodCurrentToken.state.keyCol;
    }

    return currentIndentLevel;    

}

export function getSectionPath(cm, cur, sectionPath){

    var currentIndentLevel = getCurrentLineIndent(cm, cur);
    var currentLineno = cur.line;

    if(currentIndentLevel > 0){

        // this means that we're autocompleting somewhere in the middle
        // of the YAML file and we want to look at the closest parent in
        // the schema structure to see what we can insert into the file

        var parentLevelLineInfo = getInnerParent(cm, currentLineno, currentIndentLevel);

        if(parentLevelLineInfo){

            var fieldValue = getFieldValue(cm, parentLevelLineInfo.lineno);

            sectionPath.unshift({
                sectionInfo: parentLevelLineInfo,
                sectionValue: fieldValue
            })

            // recursively walk up the indented sections of the YAML file by
            // calling sectionPath() with a similar cur object, just with the
            // line attribute modifed to match the parentLevelLineInfo.lineno
            // attribute

            var newCur = {
                ch: cur.ch,
                line: parentLevelLineInfo.lineno
            }

            getSectionPath(cm, newCur, sectionPath);

        }
        else{
            console.log("Cursor is at the level of an inner section but there's no parent section token, so something's wrong");
        }
    
    }
    else if(currentIndentLevel === 0){
        sectionPath.unshift(getTopLevelParentInfo(cm))
    }
    else{
        console.log("currentIndentLevel is < 0, so something's wrong");
    }

}

export function traverseSchemaObject(schemaObject, currentSchemaObject, sectionPath){

    if(sectionPath.length > 0){

        if(sectionPath[0].sectionValue !== ""){
            var name = sectionPath[0]["sectionInfo"]["parentLevelToken"].string.trim();
            var value = sectionPath[0]["sectionValue"];

            if(name === "typeid" && typeidRegex.test(value) && (sectionPath.length !== 1)){
                var innerSchemaObject = schemaObject[value]["takes"]["elements"];
            }
            else if(name === "typeid" && typeidRegex.test(value) && (sectionPath.length === 1)){
                var innerSchemaObject = schemaObject[value]["takes"];
            }
            else{
                var innerSchemaObject = currentSchemaObject[value];
            }
        }
        else{
            var innerSchemaObject = currentSchemaObject[sectionPath[0]["sectionInfo"]["parentLevelToken"].string.trim()];
        }
        return traverseSchemaObject(schemaObject, innerSchemaObject, sectionPath.slice(1));
    }
    else{
        return currentSchemaObject;
    }

}

export function getAlreadyUsedFields(cm, cur, parentLineno, isAtTopLevel){

    var usedFieldNames = [];

    for(var i = cur.line - 1; i > parentLineno; i--){

        var lineContent = cm.getLine(i);
        var tokenList = cm.getLineTokens(i);
        var token = getFirstUsefulToken(tokenList);

        if(token !== null){
            if(isAtTopLevel){
                if(lineContent.length > 0 &&
                        !leadingWhitespaceRegex.test(lineContent) &&
                        token.state.keyCol === 0 && token.state.pair === true &&
                        token.type !== "comment"){
                    usedFieldNames.push(token.string.trim());
                }
            }
            else{
                if(!leadingWhitespaceRegex.test(lineContent) &&
                        lineContent.length > 0){
                    usedFieldNames.push(token.string.trim());
                }
            }
        }
    }

    return usedFieldNames;

}

export function generateHintText(fieldNames, schemaObject){

    if(schemaObject.typeid === "malcolm:core/ObjectArrayMeta:1.0"){

        return fieldNames.map((fieldName) => {

            var classname = fieldName.match(typeidRegex)[1];
        
            return {
                displayText: classname,
                text: "- typeid: " + fieldName
            }
        
        })

    }
    else if(schemaObject.typeid === "malcolm:core/MapMeta:1.0" ||
            metaTypeidRegex.test(schemaObject.typeid)){

        return fieldNames.map((fieldName) => {
        
            return {
                displayText: fieldName,
                text: fieldName + ": "
            }
        
        })

    }
    else{
        console.log("Unknown schemaObject.typeid encountered:\n%s",
                schemaObject.typeid);
        return [];
    }

}
