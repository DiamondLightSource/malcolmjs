export var leadingWhitespaceRegex = /^\s*$/;

export function getFirstUsefulToken(tokenList){

    if(tokenList.length === 0){
        var firstUsefulToken = null;
    }

    for(var j = 0; j < tokenList.length; j++){
        if(tokenList[j].type !== "meta" &&
                tokenList[j].type !== null){
            var firstUsefulToken = tokenList[j];
            break;
        }
        else{
            var firstUsefulToken = null;
        }
    }

    return firstUsefulToken;
    
}

export function getFirstNonEmptyLineno(cm, lineno){

    var firstNonEmptyLineno = cm.lastLine();

    for(var i = lineno + 1; i < cm.lastLine() + 1; i++){
        var lineContent = cm.getLine(i);

        if(!leadingWhitespaceRegex.test(lineContent) && lineContent.length > 0){
            firstNonEmptyLineno = i;
            break;
        }
    }

    return firstNonEmptyLineno;

}

export function getLastNonEmptyLine(cm, lineno){

    if(lineno === 0){
        return -1;
    }

    for(var i = lineno - 1; i > -1; i--){
        var lineContent = cm.getLine(i);

        if(!leadingWhitespaceRegex.test(lineContent) && lineContent.length > 0){
            return i;
        }
    }
}

export function getInnerParent(cm, currentLineno, currentIndentLevel){

    // get token of parent section for the levels under the topmost level

    for(var i = currentLineno - 1; i > 0; i--){

        var previousLineTokens = cm.getLineTokens(i);
        var firstUsefulToken = getFirstUsefulToken(previousLineTokens);

        if(firstUsefulToken && firstUsefulToken.state.keyCol < currentIndentLevel){
            var parentLevelLineInfo = {
                parentLevelToken: firstUsefulToken,
                lineno: i
            }
            break;
        }
    }

    return parentLevelLineInfo;
}

export function getFieldValue(cm, lineno){

    var lineTokens = cm.getLineTokens(lineno);
    var typeValue = "";
    var valueFlag = false;

    for(var i = 0; i < lineTokens.length; i++){

        if(valueFlag){
            typeValue += lineTokens[i].string;
        }
        if(lineTokens[i].state.pairStart){
            valueFlag = true;
        }

    }

    return typeValue;

}

export function checkIfAtInnerSectionEnd(cm, cur, parentLevelLineInfo){

    var currentLineContent = cm.getLine(cur.line);
    var isCurrentLineEmpty = leadingWhitespaceRegex.test(currentLineContent);

    // get the first non-empty line below the current line to then compare
    // its indentation level to the parent section of the current line

    var firstNonEmptyLineno = getFirstNonEmptyLineno(cm, cur.line)
    var isNextLineIndentedToParentLevel = false;

    if(cur.ch === 0){
        var isCursorAtRightIndentLevel = cur.ch ===
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol;
    }
    else{
        var isCursorAtRightIndentLevel = cur.ch ===
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol + 2;
    }

    // check if the first non-empty line that is encountered below the
    // current one is indented to the same level that the current section's
    // parent is, or to any level above the parent's section indent level

    if(firstNonEmptyLineno !== cm.lastLine()){

        var lineTokens = cm.getLineTokens(firstNonEmptyLineno);
        var firstUsefulToken = getFirstUsefulToken(lineTokens);

        isNextLineIndentedToParentLevel = firstUsefulToken.state.keyCol <=
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol;
    
    }
    else{
        isNextLineIndentedToParentLevel = true;
    }

    return isCurrentLineEmpty && isNextLineIndentedToParentLevel &&
        isCursorAtRightIndentLevel;

}

export function checkTopPartIfAtOuterLevel(cm, cur){

    var token = cm.getTokenAt(cur);

    var lastGoodLineNumber = getLastNonEmptyLine(cm, cur.line);
    var firstGoodTokenLastLine = getFirstUsefulToken(cm.getLineTokens(lastGoodLineNumber));
    var firstGoodTokenCurrentLine = getFirstUsefulToken(cm.getLineTokens(cur.line));

    var currentLineIndent = null;
    var lastLineIndent = null;
    
    // state.keyCol has proven to be unreliable for detecting the indent
    // of tokens at times, so use it in conjunction with token.start
    // and take the minimum of the two values
    if(firstGoodTokenCurrentLine !== null){
        currentLineIndent = Math.min(firstGoodTokenCurrentLine.state.keyCol,
                firstGoodTokenCurrentLine.start);
    }
    else{
        currentLineIndent = 0;
    }

    if(firstGoodTokenLastLine !== null){
        lastLineIndent = Math.min(firstGoodTokenLastLine.state.keyCol,
                firstGoodTokenLastLine.start);
    }
    else{
        lastLineIndent = 0;
    }

    // only if both indents are 0 does it mean that the cursor is at the
    // bottom end of the file and that we're wanting to autocomplete
    // attributes on the topmost section

    if(lastLineIndent === 0 && currentLineIndent === 0){
        return true;
    }
    else{
        return false;
    }

}

export function checkBottomPartIfAtOuterLevel(cm, cur){

    for(var i = cur.line; i < cm.lastLine() + 1; i ++){
        var lineContent = cm.getLine(i);
        if(!leadingWhitespaceRegex.test(lineContent)){
            return false;
        }
    }

    return true;

}

export function getCurrentLineIndent(cm, cur){

    var token = cm.getTokenAt(cur);
    var goodCurrentToken = getFirstUsefulToken(cm.getLineTokens(cur.line));

    if(!goodCurrentToken){
        goodCurrentToken = token;
    }

    if(goodCurrentToken.start === 0 && goodCurrentToken.end === 0 &&
            goodCurrentToken.state.keyCol === 0){
        // for the case when we really have an empty line
        var currentIndentLevel = 0;
    }
    else if(goodCurrentToken.start === 0 && goodCurrentToken.end === 0 &&
            goodCurrentToken.string.length === 0){
        // for when an empty line with zero indentation gets a non-zero keyCol
        var currentIndentLevel = 0;
    }
    else if((goodCurrentToken.end - goodCurrentToken.start === 1) &&
            goodCurrentToken.state.keyCol === 0){
        // for when a line has non-zero indentation but has a zero keyCol value
        var currentIndentLevel = goodCurrentToken.end;
    }
    else{
        var currentIndentLevel = goodCurrentToken.state.keyCol;
    }

    return currentIndentLevel;    

}

export function getTopLevelParentInfo(cm){

    // for now, it's assumed that the thing whose attributes/fields are
    // being edited in the YAML file will be given at the top of the file
    // somewhere as "type: name-of-thing"
    var typeStringRegex = /type\:/;
    var topLevelParentLineno = null;

    for(var i = 0; i < cm.lastLine() + 1; i++){
    
        var lineContent = cm.getLine(i);

        if(typeStringRegex.test(lineContent)){
            topLevelParentLineno = i;
            break;
        }
    
    }

    var parentValue = getFieldValue(cm, topLevelParentLineno);
    var topLevelParentToken = getFirstUsefulToken(cm.getLineTokens(topLevelParentLineno));

    if(topLevelParentLineno !== null){
        return {
            sectionValue: parentValue,
            sectionInfo: {
                lineno: topLevelParentLineno,
                parentLevelToken: topLevelParentToken                
            }
        }
    }
    else{
        console.log("Unable to find the name of the top level parent section");
    }

}

export function getSectionPath(cm, cur, sectionPath){

    var currentIndentLevel = getCurrentLineIndent(cm, cur);
    var currentLineno = cur.line;

    if(currentIndentLevel > 0){

        // this means that we're autocompleting somewhere in the middle
        // of the YAML file and we want to look at the closest parent in
        // the schema structure to see what we can insert into the file

        var parentLevelLineInfo = getInnerParent(cm, currentLineno, currentIndentLevel);

        if(parentLevelLineInfo){

            var typeValue = getFieldValue(cm, parentLevelLineInfo.lineno);

            sectionPath.unshift({
                sectionInfo: parentLevelLineInfo,
                sectionValue: typeValue
            })

            // recursively walk up the indented sections of the YAML file by
            // calling sectionPath() with a similar cur object, just with the
            // line attribute modifed to match the parentLevelLineInfo.lineno
            // attribute

            var newCur = {
                ch: cur.ch,
                line: parentLevelLineInfo.lineno
            }

            getSectionPath(cm, newCur, sectionPath);

        }
        else{
            console.log("Cursor is at the level of an inner section but there's no parent section token, so something's wrong");
        }
    
    }
    else if(currentIndentLevel === 0){

        // checking if the cursor is at the outermost level and also not just
        // at the start of an empty line somewhere in the file
    
        var isAtBottomPart = checkBottomPartIfAtOuterLevel(cm, cur) ||
            checkTopPartIfAtOuterLevel(cm, cur);

        if(isAtBottomPart){
            sectionPath.unshift(getTopLevelParentInfo(cm))
        }

    }
    else{
        console.log("currentIndentLevel is < 0, so something's wrong");
    }

}

export function traverseSchemaObject(schemaObject, sectionPath){

    if(sectionPath.length > 0){

        if(sectionPath[0].sectionValue !== ""){
            var name = sectionPath[0]["sectionInfo"]["parentLevelToken"].string;
            var value = sectionPath[0]["sectionValue"];
            var innerSchemaObject = schemaObject[name][value];
        }
        else{
            var innerSchemaObject = schemaObject["attributes"][sectionPath[0]["sectionInfo"]["parentLevelToken"].string];
        }
        return traverseSchemaObject(innerSchemaObject, sectionPath.slice(1));
    }
    else{
        return schemaObject;
    }

}

export function getAlreadyUsedFields(cm, cur, parentLineno, isAtTopLevel){

    var usedFieldNames = [];

    for(var i = cur.line - 1; i > parentLineno; i--){

        var lineContent = cm.getLine(i);
        var tokenList = cm.getLineTokens(i);
        var token = getFirstUsefulToken(tokenList);

        if(isAtTopLevel){
            if(lineContent.length > 0 &&
                    !leadingWhitespaceRegex.test(lineContent) &&
                    token.state.keyCol === 0 && token.state.pair === true &&
                    token.type !== "comment"){
                usedFieldNames.push(token.string.trim());
            }
        }
        else{
            if(!leadingWhitespaceRegex.test(lineContent) &&
                    lineContent.length > 0){
                usedFieldNames.push(token.string.trim());
            }
        }
    }

    return usedFieldNames;

}

export function generateHintText(fieldNames, schemaObject){

    if(schemaObject.valueType === "ObjectArrayMeta"){

        return fieldNames.map((fieldName) => {
        
            return {
                displayText: fieldName,
                text: "- type: " + fieldName
            }
        
        })

    }
    else if(schemaObject.valueType === "ObjectMeta"){

        return fieldNames.map((fieldName) => {
        
            return {
                displayText: fieldName,
                text: fieldName + ": "
            }
        
        })

    }
    else{
        console.log("Unknown schemaObject.valueType encountered:\n%s",
                schemaObject.valueType);
        return [];
    }

}
