var leadingWhitespaceRegex = /^\s*$/;
var typeidRegex = /^[a-z0-9]+:[a-z0-9]+\/([a-zA-Z0-9]+):[0-9]+\.[0-9]+$/;
var metaTypeidRegex = /Meta:/;

function getFirstUsefulToken(tokenList){
    /*Find the first token in a list of tokens that has a useful type value*/

    // type: (Array[object]) -> object

    if(tokenList.length === 0){
        var firstUsefulToken = null;
    }

    for(var j = 0; j < tokenList.length; j++){
        if(tokenList[j].type !== "meta" &&
                tokenList[j].type !== null){
            var firstUsefulToken = tokenList[j];
            break;
        }
        else{
            var firstUsefulToken = null;
        }
    }

    return firstUsefulToken;
    
}

function getFirstNonEmptyLineno(cm, lineno){
    /*Find the closest non empty line that is below the current line*/

    // type: (object, int) -> int

    var firstNonEmptyLineno = -1;

    for(var i = lineno + 1; i < cm.lastLine() + 1; i++){
        var lineContent = cm.getLine(i);

        if(!leadingWhitespaceRegex.test(lineContent) && lineContent.length > 0){
            firstNonEmptyLineno = i;
            break;
        }
    }

    return firstNonEmptyLineno;

}

function getLastNonEmptyLine(cm, lineno){
    /*Find the closest non empty line that is above the current line*/

    // type: (object, int) -> int

    if(lineno === 0){
        return -1;
    }

    for(var i = lineno - 1; i > -1; i--){
        var lineContent = cm.getLine(i);

        if(!leadingWhitespaceRegex.test(lineContent) && lineContent.length > 0){
            return i;
        }
    }
}

function getInnerParent(cm, currentLineno, currentIndentLevel){
    /*Create an object containing information about the parent section of the
    line whose line number is currentLineno*/

    // type: (object, int, int) -> object

    for(var i = currentLineno - 1; i > 0; i--){

        var previousLineTokens = cm.getLineTokens(i);
        var firstUsefulToken = getFirstUsefulToken(previousLineTokens);

        if(firstUsefulToken && firstUsefulToken.state.keyCol < currentIndentLevel){
            var parentLevelLineInfo = {
                parentLevelToken: firstUsefulToken,
                lineno: i
            }
            break;
        }
    }

    return parentLevelLineInfo;
}

function getFieldValue(cm, lineno){
    /*Find the value of the field on lineno*/

    // type: (object, int) -> string

    var lineTokens = cm.getLineTokens(lineno);
    var fieldValue = "";
    var valueFlag = false;

    for(var i = 0; i < lineTokens.length; i++){

        if(valueFlag){
            fieldValue += lineTokens[i].string;
        }
        if(lineTokens[i].state.pairStart){
            valueFlag = true;
        }

    }

    return fieldValue;

}

function getTopLevelParentInfo(cm){
    /*Create object containing information about the top level parent (ie,
    the overall object being configured in the YAML file)*/

    // type: (object) -> object

    // for now, it's assumed that the thing whose attributes/fields are
    // being edited in the YAML file will be given at the top of the file
    // somewhere as "typeid: name-of-thing"
    var typeStringRegex = /typeid\:/;
    var topLevelParentLineno = null;

    for(var i = 0; i < cm.lastLine() + 1; i++){

        var lineContent = cm.getLine(i);

        if(typeStringRegex.test(lineContent)){
            topLevelParentLineno = i;
            break;
        }

    }

    var parentValue = getFieldValue(cm, topLevelParentLineno);
    var topLevelParentToken = getFirstUsefulToken(cm.getLineTokens(topLevelParentLineno));

    if(topLevelParentLineno !== null){
        return {
            sectionValue: parentValue,
            sectionInfo: {
                lineno: topLevelParentLineno,
                parentLevelToken: topLevelParentToken
            }
        }
    }
    else{
        console.log("Unable to find the name of the top level parent section");
    }

}

export function checkIfAtInnerSectionEnd(cm, cur, parentLevelLineInfo){
    /*Constrain the hint menu to not appear unless the cursor is at the end of
    the section it is in*/

    // type: (object, object, object) -> boolean

    var currentLineContent = cm.getLine(cur.line);
    var isCurrentLineEmpty = leadingWhitespaceRegex.test(currentLineContent);

    // get the first non-empty line below the current line to then compare
    // its indentation level to the parent section of the current line

    var firstNonEmptyLineno = getFirstNonEmptyLineno(cm, cur.line)
    var isNextLineIndentedToParentLevel = false;

    if(cur.ch === 0){
        var isCursorAtRightIndentLevel = cur.ch ===
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol;
    }
    else{
        var isCursorAtRightIndentLevel = cur.ch ===
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol + 2;
    }

    // check if the first non-empty line that is encountered below the
    // current one is indented to the same level that the current section's
    // parent is, or to any level above the parent's section indent level

    if(firstNonEmptyLineno !== -1){
        var lineTokens = cm.getLineTokens(firstNonEmptyLineno);
        var firstUsefulToken = getFirstUsefulToken(lineTokens);

        isNextLineIndentedToParentLevel = firstUsefulToken.state.keyCol <=
            parentLevelLineInfo.sectionInfo.parentLevelToken.state.keyCol;
    }
    else{
        isNextLineIndentedToParentLevel = true;
    }

    return isCurrentLineEmpty && isNextLineIndentedToParentLevel &&
        isCursorAtRightIndentLevel;

}

export function checkIfAtTopLevelEnd(cm, cur){
    /*Check if the cursor is at the end of the very top section (due to the
    fact that the top level section's attributes are at the same indentation
    level as the top level parent, the indentation of the top level
    section's attributes relative to the top level parent isn't a useful means
    of determining if the cursor is at the end of the top level section)*/

    // type: (object, object) -> boolean

    for(var i = cur.line; i < cm.lastLine() + 1; i ++){
        var lineContent = cm.getLine(i);
        if(!leadingWhitespaceRegex.test(lineContent)){
            return false;
        }
    }

    return true;

}

export function getCurrentLineIndent(cm, cur){
    /*Find the indentation level of the cursor's line*/

    // type: (object, object) -> int

    var token = cm.getTokenAt(cur);
    var goodCurrentToken = getFirstUsefulToken(cm.getLineTokens(cur.line));

    if(!goodCurrentToken){
        goodCurrentToken = token;
    }

    if(goodCurrentToken.start === 0 && goodCurrentToken.end === 0 &&
            goodCurrentToken.state.keyCol === 0){
        // for the case when we really have an empty line
        var currentIndentLevel = 0;
    }
    else if(goodCurrentToken.start === 0 && goodCurrentToken.end === 0 &&
            goodCurrentToken.string.length === 0){
        // for when an empty line with zero indentation gets a non-zero keyCol
        var currentIndentLevel = 0;
    }
    else if((goodCurrentToken.end - goodCurrentToken.start === 1) &&
            goodCurrentToken.state.keyCol === 0){
        // for when a line has non-zero indentation but has a zero keyCol value
        var currentIndentLevel = goodCurrentToken.end;
    }
    else{
        var currentIndentLevel = goodCurrentToken.state.keyCol;
    }

    return currentIndentLevel;    

}

export function getSectionPath(cm, cur, sectionPath){
    /*Create an array that contains all the parent sections of the cursor's
    section (beginning with the top level and going all the way down to the
    lowest section in which the cursor is in)*/

    // type: (object, object, Array[object]) -> undefined

    var currentIndentLevel = getCurrentLineIndent(cm, cur);
    var currentLineno = cur.line;

    if(currentIndentLevel > 0){

        // this means that we're autocompleting somewhere in the middle
        // of the YAML file and we want to look at the closest parent in
        // the schema structure to see what we can insert into the file

        var parentLevelLineInfo = getInnerParent(cm, currentLineno, currentIndentLevel);

        if(parentLevelLineInfo){

            var fieldValue = getFieldValue(cm, parentLevelLineInfo.lineno);

            sectionPath.unshift({
                sectionInfo: parentLevelLineInfo,
                sectionValue: fieldValue
            })

            // recursively walk up the indented sections of the YAML file by
            // calling sectionPath() with a similar cur object, just with the
            // line attribute modifed to match the parentLevelLineInfo.lineno
            // attribute

            var newCur = {
                ch: cur.ch,
                line: parentLevelLineInfo.lineno
            }

            getSectionPath(cm, newCur, sectionPath);

        }
        else{
            console.log("Cursor is at the level of an inner section but there's no parent section token, so something's wrong");
        }
    
    }
    else if(currentIndentLevel === 0){
        sectionPath.unshift(getTopLevelParentInfo(cm))
    }
    else{
        console.log("currentIndentLevel is < 0, so something's wrong");
    }

}

export function traverseSchemaObject(schemaObject, currentSchemaObject, sectionPath){
    /*Locate the MethodMeta in the lookup table that corresponds to the section
    that the cursor is in*/

    // type: (object, object, Array[object]) -> object

    if(sectionPath.length > 0){

        if(sectionPath[0].sectionValue !== ""){
            var name = sectionPath[0]["sectionInfo"]["parentLevelToken"].string.trim();
            var value = sectionPath[0]["sectionValue"];

            if(name === "typeid" && typeidRegex.test(value) && (sectionPath.length !== 1)){
                var innerSchemaObject = schemaObject[value]["takes"]["elements"];
            }
            else if(name === "typeid" && typeidRegex.test(value) && (sectionPath.length === 1)){
                var innerSchemaObject = schemaObject[value]["takes"];
            }
            else{
                var innerSchemaObject = currentSchemaObject[value];
            }
        }
        else{
            var innerSchemaObject = currentSchemaObject[sectionPath[0]["sectionInfo"]["parentLevelToken"].string.trim()];
        }
        return traverseSchemaObject(schemaObject, innerSchemaObject, sectionPath.slice(1));
    }
    else{
        return currentSchemaObject;
    }

}

export function getAlreadyUsedFields(cm, cur, parentLineno, isAtTopLevel){
    /*Figure out what fields are already defined in the cursor's section*/

    // type: (object, object, int, boolean) -> Array[string]

    var usedFieldNames = [];

    for(var i = cur.line - 1; i > parentLineno; i--){

        var lineContent = cm.getLine(i);
        var tokenList = cm.getLineTokens(i);
        var token = getFirstUsefulToken(tokenList);

        if(token !== null){
            if(isAtTopLevel){
                if(lineContent.length > 0 &&
                        !leadingWhitespaceRegex.test(lineContent) &&
                        token.state.keyCol === 0 && token.state.pair === true &&
                        token.type !== "comment"){
                    usedFieldNames.push(token.string.trim());
                }
            }
            else{
                if(!leadingWhitespaceRegex.test(lineContent) &&
                        lineContent.length > 0){
                    usedFieldNames.push(token.string.trim());
                }
            }
        }
    }

    return usedFieldNames;

}

export function generateHintText(fieldNames, schemaObject){
    /*Create an array that contains the information codemirror needs to
    display the appropriate entries in the hint menu*/

    // type: (Array[string], object) -> Array[object]

    if(schemaObject.typeid === "malcolm:core/ObjectArrayMeta:1.0"){

        return fieldNames.map((fieldName) => {

            var classname = fieldName.match(typeidRegex)[1];
        
            return {
                displayText: classname,
                text: "- typeid: " + fieldName
            }
        
        })

    }
    else if(schemaObject.typeid === "malcolm:core/MapMeta:1.0" ||
            metaTypeidRegex.test(schemaObject.typeid)){

        return fieldNames.map((fieldName) => {
        
            return {
                displayText: fieldName,
                text: fieldName + ": "
            }
        
        })

    }
    else{
        console.log("Unknown schemaObject.typeid encountered:\n%s",
                schemaObject.typeid);
        return [];
    }

}
